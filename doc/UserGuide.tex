\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{braket}
\usepackage{bm}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
}
\usepackage[%
  colorlinks=true,
  urlcolor=blue,
  linkcolor=blue,
  citecolor=blue
]{hyperref}
\usepackage{geometry}
\geometry{
  a4paper,
  total= {170mm,257mm},
  left = 2cm,
  top  = 2cm,
}
\title{SsTC library:\\
\large{User's Guide}\\
\large{Version 0.2.0}}
\author{Ãlvaro R. Puente-Uriona}
\date{\today}
\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Scope}
Solid-state Task Constructor (SsTC) is a hight performance computing (HPC) oriented Fortran library which aims to aid programmers and researchers in the process of sampling and integration of functions in the first Brillouin zone (BZ) of a given crystalline system. The library is centred around the following concepts.
\begin{itemize}
\item The calculator: A general function representing a physical quantity of interest to the programmer or researcher. It is of the form
\begin{equation}\label{eq:calculator}
C^{\bm{\alpha}}(\bm{k}; \bm{\beta}),
\end{equation}
where $\bm{k}$ is a vector in the BZ and $\bm{\alpha}, \bm{\beta}$ encompass \textit{all} other functional dependences of $C$. In the document we refer to $\bm{\alpha}$ as integer or discrete indices and seek to represent, for example, a set of Cartesian components $\{x, y, z\}$ or band indices. On the other side, $\bm{\beta}$ are referred as continuous indices and seek to represent the dependence of $C$ on non-intrinsic variables such as an externally controlled frequency $\omega$ or a variable range of Fermi energies $\varepsilon_F$.
\item The task: An object containing a complete description of the calculator $C$ and the sampling or integration task that the programmer wants to make.
\item The system: An object containing a complete description of a crystalline system given by its tight-binding \cite{marzariMaximallyLocalizedWannier2012} representation. This includes:
\begin{itemize}
\item Number of bands.
\item Fermi energy.
\item Unit cell description: the projection of lattice vectors $\bm{a}_i$ in the $\{x, y, z\}$ axes in units of \r{A}.
\item Resolution of the Hamiltonian operator $\hat{H}$ in the basis of the Wannier functions (WFs) \cite{marzariMaximallyLocalizedWannier2012} in units of eV, i.e., the on-site and tunnelling amplitudes.
\item Resolution of the position operator $\hat{\bm{r}}$ in the basis of the WFs in units of \r{A}.
\end{itemize}
\end{itemize}
The sampling and integration utilities contained in SsTC are the following.
\begin{itemize}
\item ``Kpath" sampling. 1-dimensional sampling of $C$ with specification of the path to sample.
\item ``Kslice" sampling. 2-dimensional regular sampling of $C$ with specification of the slice to sample.
\item ``Regular" sampling. 3-dimensional regular sampling of $C$ with specification of the number of samples in each dimension.
\item Integration. 3-dimensional regular sampling of $C$ followed by an integration process. The integration process as for v0.2.0 amounts to the rectangle approximation in each dimension. There exists also an experimental integration method based on extrapolation methods.
\end{itemize}
All the concepts covered in this section are treated with greater detail in the specific sections in the document.
\section{Installation \& linking to application}
As for v0.2.0, the library is only guaranteed to compile on Linux systems using the \verb|mpiifort| and \verb|mpiifx| compilers contained in the \href{https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit.html}{Intel\textregistered oneAPI HPC} toolkit. As such, the main application to be linked with must be compiled with \verb|mpiifort| or \verb|mpiifx|.

The SsTC project is hosted on \href{https://github.com/irukoa/SsTC}{GitHub} and can be downloaded by running the command
\begin{verbatim}
git clone --recurse-submodules https://github.com/irukoa/SsTC.git
\end{verbatim}
or by downloading a compressed version of the source code on the \href{https://github.com/irukoa/SsTC/tags}{tag history}.

To install the source code move the \verb|SsTC| folder to a path of your choice and run \verb|make|.
\begin{verbatim}
bash:/current/dir$ mv SsTC/ /path/of/your/choice/
bash:/path/of/your/choice$ cd SsTC/
bash:/path/of/your/choice/SsTC$ make
\end{verbatim}
These commands will compile the source code and install the library \verb|libSsTC.a| and the module header file \verb|sstc.mod| in the directory \verb|/path/of/your/choice/SsTC/bin/|.

To link to your Fortran application \verb|appl.F90|, add the line \verb|use SsTC| in your application preamble and compile with 
\begin{verbatim}
bash:/path/to/application/$ $(F90) $(F90FLAGS) appl.F90 
-I/path/of/your/choice/SsTC/bin 
/path/of/your/choice/SsTC/bin/libSsTC.a -o "appl.x"
\end{verbatim}
where \verb|F90 = mpiifort/mpiifx| and \verb|F90FLAGS| contains, at least,
\begin{verbatim}
F90FLAGS = -qopenmp -lmkl_intel_lp64 -lmkl_core -lmkl_gnu_thread -pthread
\end{verbatim}

To make use of SsTC, the application preamble of \verb|appl.F90| should contain also the lines 
\begin{verbatim}
use MPI_F08
use OMP_LIB
\end{verbatim}
The application must contain also a call to the MPI \cite{messagepassinginterfaceforumMPIMessagePassingInterface2021} initialization routine \verb|call MPI_INIT(ierror)| and to the SsTC initialization routine \verb|call SsTC_init()| \textit{before} any call to other SsTC routines. The programmer also need to make sure that the MPI finalizing routine \verb|call MPI_FINALIZE(ierror)| has not been called before using SsTC routines.

Note:  By default SsTC uses double precision \verb|dp, kind=8| numbers for real and complex valued scalars and arrays.

The application \verb|appl.x| can be run by the commands
\begin{verbatim}
/path/to/application/appl.x
mpirun -np $N /path/to/application/appl.x
\end{verbatim}
\section{Calculators \& tasks}
The calculator Eq. \eqref{eq:calculator} is the generic name for Fortran function with interface
\begin{lstlisting}[caption={Interface of a general calculator.},captionpos=b, label={lst:interface_g_calc}]
abstract interface
  function SsTC_global_calculator(task, system, k, error) &
           result(u)
    class(SsTC_global_k_data), intent(in) :: task
    type(SsTC_sys), intent(in)            :: system
    real(kind=dp), intent(in)             :: k(3)
    !In coords. relative to recip. lattice vectors.
    logical, intent(inout)                :: error

    complex(kind=dp) :: u(product(task%integer_indices), &
                          product(task%continuous_indices))
  end function SsTC_global_calculator
end interface
\end{lstlisting}
given by one of the SsTC modules, see Sec. \ref{sec:modularity}, or otherwise provided by the user in the scope of the main application using SsTC. The calculator must be interface conforming.

Additionally to the general ``global calculator", there exists a ``local calculator" with interface
\begin{lstlisting}[caption={Interface of a local calculator.},captionpos=b, , label={lst:interface_l_calc}]
abstract interface
  function SsTC_local_calculator(k_data, system, k, error) &
           result(u)
    class(SsTC_local_k_data), intent(in) :: k_data
    type(SsTC_sys), intent(in)           :: system
    real(kind=dp), intent(in)            :: k(3)
    !In coords. relative to recip. lattice vectors.
    logical, intent(inout)               :: error

    complex(kind=dp) :: u(product(k_data%integer_indices))
  end function SsTC_local_calculator
end interface
\end{lstlisting}
with reduced functionality and meant for internal computations regarding quantities local for each $\bm{k}$ point, as described in Sec. \ref{sec:local_k_quantities}.

The task is a Fortran object (derived type) of \verb|class(SsTC_local_k_data)|, of which \\ \verb|type(SsTC_global_k_data)| is an extension, specifying the sampling or integration task to perform and contains a full description of the properties of the calculator. The generic properties which apply to every task \verb|task| are the following,
\begin{itemize}
\item \verb|character(len=*) :: task%name|: The name given to the task.
\item \verb|procedure(SsTC_global_calculator), pointer :: task%global_calculator|: Interface conforming procedure pointer to the selected calculator. The library's sampling routines will use the provided calculator to sample.
\item \verb|integer :: task%integer_indices(N_int_ind)|: Each entry \verb|i| of the array contains the number of values the integer index $\alpha_i$ in Eq. \eqref{eq:calculator} can have. \verb|N_int_ind| is the total number of integer indices encompassed by $\bm{\alpha}$ and the total number of integer index combinations is given by \verb|product(task%integer_indices)|.
\item \verb|integer :: task%continuous_indices(N_ext_vars)|: Each entry \verb|i| of the array contains the number \verb|ext_vars_steps(i)| of values the continuous index $\beta_i$ in Eq. \eqref{eq:calculator} can have. \verb|N_ext_vars| is the total number of external variables encompassed by $\bm{\beta}$ and the total number of continuous index combinations is given by \verb|product(task%continuous_indices)|. Not applicable to \verb|type(SsTC_local_k_data)|.
\item \verb|real(kind=dp) :: task%ext_var_data(N_ext_vars)%data(ext_vars_steps(N_ext_vars))|: Each entry \verb|i, j| corresponding to \verb|task%ext_var_data(i)%data(j)| is a real number $\lambda_{ij}$ containing the particular value the continuous index $\beta_{i}$ has, as given by
\begin{equation}\label{eq:disc_cont}
\lambda_{ij} = \lambda_{i1} + \left(\lambda_{i\;\verb|ext_vars_steps(i)|} - \lambda_{i1}\right)\times\left(j - 1\right)/\left(\verb|ext_vars_steps(i)| - 1\right).
\end{equation}
where $\lambda_{i1}$ and $\lambda_{i\;\verb|ext_vars_steps(i)|}$ are the starting and ending points of the values given to $\beta_{i}$, $j\in [1, \verb|ext_vars_steps(i)|]$. Not applicable to \verb|type(SsTC_local_k_data)|.
\end{itemize}
Particular tasks can be created by means of a specific sampling or integrator task constructor as described in Sec. \ref{sec: sampling_integration} or by the programmer with complete freedom. Extension of the task members is also possible by means of derived type extension.

In the following we provide the type declarations of \verb|SsTC_local_k_data| and \verb|SsTC_global_k_data|,
\begin{lstlisting}[caption={Derived type corresponding to ``local k data".},captionpos=b]
type SsTC_local_k_data
  character(len=120)                                :: name
  integer, allocatable                              :: integer_indices(:)
  !Each entry contains the range of each of the integer indices.
  complex(kind=dp), allocatable                     :: k_data(:)
  !Data local for each k with integer index in memory array.
  procedure(SsTC_local_calculator), pointer, nopass :: local_calculator => null()
  !Pointer to the local calculator.
  integer                                           :: particular_integer_component = 0 
  !Specification of some integer component.
end type SsTC_local_k_data
\end{lstlisting}
\begin{lstlisting}[caption={Derived type corresponding to ``global k data".},captionpos=b]
type, extends(SsTC_local_k_data) :: SsTC_global_k_data
  integer, allocatable                               :: continuous_indices(:)
  !Each entry contains the range of each continuous indices.
  type(SsTC_external_vars), allocatable              :: ext_var_data(:)
  !External variable data.
  procedure(SsTC_global_calculator), pointer, nopass :: global_calculator => null()
  !Pointer to the global calculator.
  integer, allocatable                               :: iterables(:, :)
  !Iterable dictionary.
end type SsTC_global_k_data
\end{lstlisting}
\section{SsTC initialization}
SsTC can be initialized in the application by using the routine \verb|SsTC_init()|. 
\begin{lstlisting}[caption={Interface of ``SsTC initialization".},captionpos=b]
subroutine SsTC_init(nThreads, nNested, exec_label)

  integer, intent(in), optional :: nThreads 
  !Default are max available threads per MPI process.
  integer, intent(in), optional :: nNested !Default = 1.
  character(len=*), intent(in), optional :: exec_label !Default "SsTC_exec".
    
end subroutine SsTC_init
\end{lstlisting}
The routine will check wether MPI has been initialized and stop the program on execution if it was not initialized. It will also open the output and error log files \verb|file=trim(exec_label//".out")| and \\ \verb|file=trim(exec_label//".err")|. The user can also control the nunber of parallel nested regions with the variable \verb|nNested|. Changing this variable from the default value of 1 is not recommended unless the number of $\bm{k}$ points being sampled by a particular task is smaller than the total number of threads available. Lastly, \verb|nThreads| sets the number of threads per MPI process, with the default value of \verb|OMP_GET_MAX_THREADS()|.
\section{Notation: Memory layout and array layout}\label{sec:notation}
These concepts apply to $N$-dimensional arrays such as \verb|array(:, :, ..., :)|, where each dimension $i$ has size $s_i$. The total size of \verb|array| is
\begin{equation}
\verb|size(array)| = \prod_{i=1}^N s_i.
\end{equation}
An array with such a shape is said to be in ``array layout". In tandem this layout, we consider now the 1-dimensional array \verb|mem(:)|, with the same size as \verb|array|. The array \verb|mem(:)| is defined as the ``memory layout" counterpart of the array \verb|array| if
\begin{equation}
\verb|mem(r)| = \verb|array(n_1, n_2, ..., n_N)|,
\end{equation}
with
\begin{equation}\label{eq:column_mayor_mapping}
r = n_1 + s_1\left(n_2 + s_2\left(n_3 + \cdots\right)\cdots\right) = \sum_{i=1}^N n_i\times \left(\prod_{j=1}^{i-1}s_j\right).
\end{equation}
This mapping is called the \href{https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays}{column mayor} array to memory index mapping. It provides an invertible relation
\begin{equation}
r \Leftrightarrow \{n_1, n_2, \cdots, n_N\},
\end{equation}
which makes it possible to keep track of the elements of an array in both layouts, provided that the sizes $s_i$ are known. The output values of the calculators, corresponding to the sampling $C^{\alpha}(\bm{k};\beta)$ for a $\bm{k}$ vector, are always arrays in memory layout, both for integer and continuous indices, which makes the interface of the calculator flexible for any number of integer or continuous indices.

In SsTC, the sizes $s_i$ of integer or continuous indices are specified by the components \\ \verb|task%integer_indices| and \verb|task%continuous_indices| of the task \verb|class(SsTC_local_k_data) :: task|, respectively. The library provides the utilities
\begin{itemize}
\item \verb|SsTC_integer_array_element_to_memory_element|: Returns $r = f(\{n_1, n_2, \cdots, n_N\})$ for integer indices.
\item \verb|SsTC_integer_memory_element_to_array_element|: Returns $\{n_1, n_2, \cdots, n_N\} = f^{-1}(r)$ for integer indices.
\item \verb|SsTC_continuous_array_element_to_memory_element|: Returns $r = f(\{n_1, n_2, \cdots, n_N\})$ for continuous indices.
\item \verb|SsTC_continuous_memory_element_to_array_element|: Returns $\{n_1, n_2, \cdots, n_N\} = f^{-1}(r)$ for continuous indices.
\end{itemize}
where $f$ is a function representing the mapping Eq. \eqref{eq:column_mayor_mapping} and $f^{-1}$ represents its inverse mapping. The four utilities are described in detail in Sec. \ref{sec:data_structures}.
\section{Systems}
A system is a Fortran derived type
\begin{lstlisting}[caption={Derived type corresponding to a system.},captionpos=b]
type SsTC_sys
  character(len=120)            :: name
  integer                       :: num_bands
  real(kind=dp)                 :: direct_lattice_basis(3, 3)
  !1st index is vector label, 2nd index is vector component.
  real(kind=dp)                 :: metric_tensor(3, 3)
  !Metric tensor of the direct lattice basis.
  real(kind=dp)                 :: cell_volume
  integer                       :: num_R_points
  !Number of R points (unit cells).
  integer, allocatable          :: R_point(:, :)
  !Id of the R-point (1st index) and R-vector coords. 
  !relative to the direct lattice basis vectors (2nd index).
  integer, allocatable          :: deg_R_point(:)
  !Degeneracy of the R-point specified by its memory layout id.
  complex(kind=dp), allocatable :: real_space_hamiltonian_elements(:, :, :)
  !Hamiltonian matrix elements (1st and 2nd indexes) and 
  !id of the R-point (3rd index) in eV.
  complex(kind=dp), allocatable :: real_space_position_elements(:, :, :, :) 
  !Position operator matrix elements (1st and 2nd indexes), 
  !cartesian coordinate (3rd index) and id of the R-point (4th index) in A.
  real(kind=dp)                 :: e_fermi = 0.0_dp
  !Fermi energy.
  real(kind=dp)                 :: deg_thr = 1.0E-4_dp
  !Degeneracy threshold in eV.
  real(kind=dp)                 :: deg_offset = 0.04_dp
  !Offset for regularization in case of degeneracies, in eV.
end type SsTC_sys
\end{lstlisting}
representing a crystalline system by its tight-binding \cite{marzariMaximallyLocalizedWannier2012} representation. The components
\begin{equation}
\verb|real_space_hamiltonian_elements(m, n, id)| = \braket{m\bm{0}|\hat{H}|n\bm{R}},\quad \verb|id|\;\text{corresponds to }\bm{R}.
\end{equation}
and
\begin{equation}
\verb|real_space_position_elements(m, n, i, id)| = \braket{m\bm{0}|\hat{r}_i|n\bm{R}},\quad \verb|id|\;\text{corresponds to }\bm{R}.
\end{equation}
are identified.
The recommended way to create system is by using the function \verb|SsTC_sys_constructor|,
\begin{lstlisting}[caption={Interface of the system constructor.},captionpos=b]
function SsTC_sys_constructor(name, path_to_tb_file, &
                              efermi, deg_thr, deg_offset) &
  result(system)

  character(len=*), intent(in)        :: name
  character(len=*), intent(in)        :: path_to_tb_file
  real(kind=dp), optional, intent(in) :: efermi, &
                                         deg_thr, deg_offset

  type(SsTC_sys) :: system
end function SsTC_sys_constructor
\end{lstlisting}
where the optional arguments can be specified. The function will try to read a file named \\ \verb|trim(path_to_tb_file)//trim(name)//"_tb.dat"| in the path relative to the main application directory. The files have the format of a \href{https://wannier.org/}{Wannier90} \cite{pizziWannier90CommunityCode2020} \href{https://raw.githubusercontent.com/wannier-developers/wannier90/v3.1.0/doc/compiled_docs/user_guide.pdf}{tight-binding} (\verb|*_tb.dat| file, see Sec. 8.21 of the Wannier90 user's guide for v3.1.0) which can be written by the user for toy tight-binding models or can be generated by the code Wannier90 from postprocessing \textit{ab-initio} calculations. As for v3.1.0 of Wannier90, the file is automatically generated when running \verb|wannier90.x| if the option \verb|write_tb=.TRUE.| is specified in the Wannier90 input card (\verb|*.win| file).
\section{Sampling and integration routines}\label{sec: sampling_integration}
In this section we describe the main routines of the SsTC library, encompassing task creation, task sampling or integration and printing to files. Note that the sampling or integration subroutines take as inputs tasks corresponding to the same \verb|class| as the tasks generated by the respective task constructors, which are, at the same time, extensions of \verb|class(SsTC_global_k_data)|. As such, much flexibility in the definition of calculators can be achieved by means of type extension.
\subsection{Kpath module}
This module is centred around creating, sampling and printing tasks which involve a path in reciprocal space. The ``kpath" task is a derived type
\begin{lstlisting}[caption={Derived type corresponding to a ``kpath" task.},captionpos=b]
type, extends(SsTC_global_k_data) :: SsTC_kpath_task
  !1st index is the id of the vector in the path.
  !2nd index corresponds to the component of the vector
  !in the path in coordinates relative to the reciprocal lattice.
  real(kind=dp), allocatable :: vectors(:, :)
  !number_of_pts(i) contains the number of k-points between vector i and vector i+1.
  integer, allocatable :: number_of_pts(:)
  !Array to store data with integer index,
  !continuous index and kpt index respectively.
  complex(kind=dp), allocatable :: kpath_data(:, :, :)
end type SsTC_kpath_task
\end{lstlisting}
where we consider a set of $N$ reciprocal space vectors $\{\bm{q}_i, i\in[1, N]\}$ by their components $\{a_{ij}\}$ relative to the reciprocal space basis vectors $\bm{b}_{\{1, 2, 3\}}$,
\begin{equation}\label{eq:vec_coords_path}
\bm{q}_i = \sum_{j=1}^3 a_{ij}\times \bm{b}_j, \quad a_{ij}\in\left[-0.5, 0.5\right],
\end{equation}
and identify
\begin{equation}
\verb|vectors(i, j)| = a_{ij}.
\end{equation}
The array \verb|number_of_pts(i)| contains the number of points between vector $\bm{q}_i$ and vector $\bm{q}_{i+1}$. For the general calculator Eq. \eqref{eq:calculator}, we identify
\begin{equation}
\verb|kpath_data(alpha, beta, ik)| = C^{\alpha}(\bm{k},\beta),\quad \bm{k}\text{ is identified with } \verb|ik|,
\end{equation}
with
\begin{equation}
\bm{k} = \bm{q}_i + (\bm{q}_{i+1} - \bm{q}_i)\times (\verb|ik| - 1)/(\verb|number_of_pts(i)| - 1).
\end{equation}
A ``kpath" task can be constructed by the function \verb|SsTC_kpath_constructor|,
\begin{lstlisting}[caption={Interface of the ``kpath" constructor.},captionpos=b]
subroutine SsTC_kpath_constructor(task, name, &
                                  l_calculator, g_calculator, &
                                  Nvec, vec_coord, nkpts, &
                                  N_int_ind, int_ind_range, &
                                  N_ext_vars, ext_vars_start, ext_vars_end, &
                                  ext_vars_steps, &
                                  part_int_comp)

  character(len=*) :: name

  procedure(SsTC_local_calculator), optional  :: l_calculator
  procedure(SsTC_global_calculator), optional :: g_calculator

  integer, intent(in)       :: Nvec
  real(kind=dp), intent(in) :: vec_coord(Nvec, 3)
  integer, intent(in)       :: nkpts(Nvec - 1)

  integer, optional, intent(in) :: N_int_ind
  integer, optional, intent(in) :: int_ind_range(N_int_ind)

  integer, optional, intent(in)       :: N_ext_vars
  real(kind=dp), optional, intent(in) :: ext_vars_start(N_ext_vars), &
                                         ext_vars_end(N_ext_vars)
  integer, optional, intent(in)       :: ext_vars_steps(N_ext_vars)

  integer, optional, intent(in) :: part_int_comp(N_int_ind)

  class(SsTC_kpath_task), intent(out) :: task
end subroutine SsTC_kpath_constructor
\end{lstlisting}
where
\begin{itemize}
\item \verb|name|: Name given to the task.
\item \verb|l_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_l_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|g_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_g_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|Nvec|: Number of vectors in the path.
\item \verb|vec_coord(i, j)|: Vector coordinates $a_{ij}$ in Eq. \eqref{eq:vec_coords_path}.
\item \verb|nkpts(i)|: Number of points between vectors $\bm{q}_i$ and $\bm{q}_{i+1}$.
\item \verb|N_int_ind|: Number of integer indices.
\item \verb|int_ind_range(i)|: Number of values the integer index $\alpha_i$ can have.
\item \verb|N_ext_vars|: Number of continuous variables.
\item \verb|ext_vars_start(i)|: Starting point $\lambda_{i1}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_end(i)|: Ending point $\lambda_{i\;\verb|ext_vars_steps(i)|}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_steps(i)|: Number of points into which to descretize the variable $\beta_i$.
\item \verb|part_int_comp(N_int_ind)|: Array corresponding to a selection of a particular integer component in array layout.
\end{itemize}
Sampling, and thus writing the values of $C$ in Eq. \eqref{eq:calculator} given by \verb|l_calculator| or \verb|g_calculator| to the array \verb|kpath_data| can be made with the subroutine \verb|SsTC_kpath_sampler|.
\begin{lstlisting}[caption={Interface of the ``kpath" sampler.},captionpos=b]
subroutine SsTC_kpath_sampler(task, system)
  class(SsTC_kpath_task), intent(inout) :: task
  type(SsTC_sys), intent(in)            :: system
end subroutine SsTC_kpath_sampler
\end{lstlisting}
All the \verb|allocatable| components of both \verb|task| and \verb|system| should be allocated before the subroutine call either by the corresponding constructors or by the user.

Writing to files can be done by means of the subroutine \verb|SsTC_print_kpath|.
\begin{lstlisting}[caption={Interface of the ``kpath" printer.},captionpos=b]
subroutine SsTC_print_kpath(task, system)
  class(SsTC_kpath_task), intent(in) :: task
  type(SsTC_sys), intent(in)         :: system
end subroutine SsTC_print_kpath
\end{lstlisting}
The routine will write a file for each integer index with name \\ \verb|trim(system%name)//'-'//trim(task%name)//'_'trim(num_label)//'.dat'| with num label being an \\ \verb|N_int_ind|-dimensional array with the corresponding integer index in array layout (see Sec. \ref{sec:notation}). Each file will contain, column by column, the following,
\begin{itemize}
\item An \verb|id| corresponding to the particular $\bm{k}$ point being sampled (1 column).
\item The components $a_{i\{1, 2, 3\}}$ in Eq. \eqref{eq:vec_coords_path} of the vector $\bm{k}$ corresponding to \verb|id| (3 columns).
\item For each continuous index $i$, the particular values of the data $\lambda_{ij}$ as given by Eq. \eqref{eq:disc_cont} \\ (\verb|size(task%continuous_indices)| columns).
\item The real and imaginary part of the calculator $C^{\alpha}(\bm{k};\beta)$ (2 columns).
\end{itemize}
If further use of the sampled data is intended within the execution of the application, making a copy of \verb|task%kpath_data| is suggested.
\subsection{Kslice module}
This module is centred around creating, sampling and printing tasks which involve a 2-dimensional reciprocal space ``slice". The ``kslice" task is a derived type
\begin{lstlisting}[caption={Derived type corresponding to a ``kslice" task.},captionpos=b]
type, extends(SsTC_global_k_data) :: SsTC_kslice_task
  !Default: sample k_z = 0 slice in a 100x100 mesh.
  real(kind=dp) :: corner(3) = (/-0.5_dp, -0.5_dp, 0.0_dp/), &
                   vector(2, 3) = reshape((/1.0_dp, 0.0_dp, 0.0_dp, &
                   1.0_dp, 0.0_dp, 0.0_dp/), (/2, 3/))
  integer       :: samples(2) = (/100, 100/)
  !Integer index, continuous index and kpt index 1 and 2 respectively.
  complex(kind=dp), allocatable :: kslice_data(:, :, :, :)
end type SsTC_kslice_task
\end{lstlisting}
where we consider 3 reciprocal space vectors $\{\bm{q}_i, i\in[1, 3]\}$ by their components $\{a_{ij}\}$ relative to the reciprocal space basis vectors $\bm{b}_{\{1, 2, 3\}}$,
\begin{equation}\label{eq:vec_coords_slice}
\bm{q}_i = \sum_{j=1}^3 a_{ij}\times \bm{b}_j, \quad a_{ij}\in\left[-0.5, 0.5\right],
\end{equation}
and identify the two vectors spanning a plane
\begin{equation}
\verb|vector(i, j)| = a_{ij}, \quad i = [1, 2].
\end{equation}
We also identify the ``sampling corner" or starting point
\begin{equation}
\verb|corner(j)| = a_{3, j}.
\end{equation}
For the general calculator Eq. \eqref{eq:calculator}, we identify
\begin{equation}
\verb|kslice_data(alpha, beta, ik1, ik2)| = C^{\alpha}(\bm{k},\beta),\quad \bm{k}\text{ is identified with } \verb|ik1, ik2|,
\end{equation}
and given by
\begin{equation}
\bm{k} = \verb|corner| + \bm{q}_1\times (\verb|ik1|-1)/(\verb|samples(1)| - 1) + \bm{q}_2\times (\verb|ik2|-1)/(\verb|samples(2)| - 1).
\end{equation}
A ``kslice" task can be constructed by the function \verb|SsTC_kslice_task_constructor|,
\begin{lstlisting}[caption={Interface of the ``kslice" constructor.},captionpos=b]
subroutine SsTC_kslice_task_constructor(task, name, &
                                        l_calculator, g_calculator, &
                                        corner, vector_a, vector_b, samples, &
                                        N_int_ind, int_ind_range, &
                                        N_ext_vars, ext_vars_start, ext_vars_end, &
                                        ext_vars_steps, &
                                        part_int_comp)

  character(len=*) :: name

  procedure(SsTC_local_calculator), optional  :: l_calculator
  procedure(SsTC_global_calculator), optional :: g_calculator

  real(kind=dp), optional, intent(in) :: corner(3), vector_a(3), vector_b(3)
  integer, optional, intent(in)       :: samples(2)

  integer, optional, intent(in) :: N_int_ind
  integer, optional, intent(in) :: int_ind_range(N_int_ind)

  integer, optional, intent(in)       :: N_ext_vars
  real(kind=dp), optional, intent(in) :: ext_vars_start(N_ext_vars), &
                                         ext_vars_end(N_ext_vars)
  integer, optional, intent(in)       :: ext_vars_steps(N_ext_vars)

  integer, optional, intent(in) :: part_int_comp(N_int_ind)

  class(SsTC_kslice_task), intent(out) :: task
end subroutine SsTC_kpath_constructor
\end{lstlisting}
where
\begin{itemize}
\item \verb|name|: Name given to the task.
\item \verb|l_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_l_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|g_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_g_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|corner(3)|: Starting point of the sampling.
\item \verb|vector_a(3)|: Vector coordinates $a_{1j}$ in Eq. \eqref{eq:vec_coords_slice}.
\item \verb|vector_b(3)|: Vector coordinates $a_{2j}$ in Eq. \eqref{eq:vec_coords_slice}.
\item \verb|samples(2)|: Each entry $i$ contains the number into which $\bm{q}_i$ has been discretized.
\item \verb|N_int_ind|: Number of integer indices.
\item \verb|int_ind_range(i)|: Number of values the integer index $\alpha_i$ can have.
\item \verb|N_ext_vars|: Number of continuous variables.
\item \verb|ext_vars_start(i)|: Starting point $\lambda_{i1}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_end(i)|: Ending point $\lambda_{i\;\verb|ext_vars_steps(i)|}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_steps(i)|: Number of points into which to descretize the variable $\beta_i$.
\item \verb|part_int_comp(N_int_ind)|: Array corresponding to a selection of a particular integer component in array layout.
\end{itemize}
Sampling, and thus writing the values of $C$ in Eq. \eqref{eq:calculator} given by \verb|l_calculator| or \verb|g_calculator| to the array \verb|kslice_data| can be made with the subroutine \verb|SsTC_sample_kslice_task|.
\begin{lstlisting}[caption={Interface of the ``kslice" sampler.},captionpos=b]
subroutine SsTC_sample_kslice_task(task, system)
  class(SsTC_kslice_task), intent(inout) :: task
  type(SsTC_sys), intent(in)             :: system
end subroutine SsTC_sample_kslice_task
\end{lstlisting}
All the \verb|allocatable| components of both \verb|task| and \verb|system| should be allocated before the subroutine call either by the corresponding constructors or by the user.

Writing to files can be done by means of the subroutine \verb|SsTC_print_kslice|.
\begin{lstlisting}[caption={Interface of the ``kslice" printer.},captionpos=b]
subroutine SsTC_print_kslice(task, system)
  class(SsTC_kpath_task), intent(in) :: task
  type(SsTC_sys), intent(in)         :: system
end subroutine SsTC_print_kslice
\end{lstlisting}
The routine will write a file for each integer index with name \\ \verb|trim(system%name)//'-'//trim(task%name)//'_'trim(num_label)//'.dat'| with num label being an \\ \verb|N_int_ind|-dimensional array with the corresponding integer index in array layout (see Sec. \ref{sec:notation}). Each file will contain, column by column, the following,
\begin{itemize}
\item The components $a_{i\{1, 2, 3\}}$ in Eq. \eqref{eq:vec_coords_slice} of the vector $\bm{k}$ corresponding to \verb|id| (2 columns).
\item For each continuous index $i$, the particular values of the data $\lambda_{ij}$ as given by Eq. \eqref{eq:disc_cont} \\ (\verb|size(task%continuous_indices)| columns).
\item The real and imaginary part of the calculator $C^{\alpha}(\bm{k};\beta)$ (2 columns).
\end{itemize}
If further use of the sampled data is intended within the execution of the application, making a copy of \verb|task%kslice_data| is suggested.
\subsection{Sampler module}
This module is centred around creating, sampling and printing tasks which involve a 3-dimensional BZ sampling. The ``sampler" task is a derived type
\begin{lstlisting}[caption={Derived type corresponding to a ``sampler" task.},captionpos=b]
type, extends(SsTC_global_k_data) :: SsTC_sampling_task
  integer                       :: samples(3) = (/100, 100, 100/)
  !Integer index, continuous index and kpt index 1, 2 and 3 respectively.
  complex(kind=dp), allocatable :: BZ_data(:, :, :, :, :)
end type SsTC_sampling_task
\end{lstlisting}
For the general calculator Eq. \eqref{eq:calculator}, and the reciprocal space basis vectors $\bm{b}_{\{1, 2, 3\}}$, we identify
\begin{equation}
\verb|BZ_data(alpha, beta, ik1, ik2, ik3)| = C^{\alpha}(\bm{k},\beta),\quad \bm{k}\text{ is identified with } \verb|ik1, ik2, ik3|,
\end{equation}
and given by
\begin{equation}\label{eq:vec_coords_sampler}
\bm{k} = \sum_{i=1}^3 \bm{b}_i\times (\verb|ik|i-1)/(\verb|samples(i)| - 1).
\end{equation}
A ``sampler" task can be constructed by the function \verb|SsTC_sampling_task_constructor|,
\begin{lstlisting}[caption={Interface of the ``sampler" constructor.},captionpos=b]
subroutine SsTC_sampling_task_constructor(task, name, &
                                          l_calculator, g_calculator, &
                                          samples, &
                                          N_int_ind, int_ind_range, &
                                          N_ext_vars, &
                                          ext_vars_start, ext_vars_end, &
                                          ext_vars_steps, &
                                          part_int_comp)

  character(len=*) :: name

  procedure(SsTC_local_calculator), optional  :: l_calculator
  procedure(SsTC_global_calculator), optional :: g_calculator

  integer, optional, intent(in) :: samples(3)

  integer, optional, intent(in) :: N_int_ind
  integer, optional, intent(in) :: int_ind_range(N_int_ind)

  integer, optional, intent(in)       :: N_ext_vars
  real(kind=dp), optional, intent(in) :: ext_vars_start(N_ext_vars), &
                                         ext_vars_end(N_ext_vars)
  integer, optional, intent(in)       :: ext_vars_steps(N_ext_vars)

  integer, optional, intent(in) :: part_int_comp(N_int_ind)

  class(SsTC_sampling_task), intent(out) :: task
end subroutine SsTC_sampling_task_constructor
\end{lstlisting}
where
\begin{itemize}
\item \verb|name|: Name given to the task.
\item \verb|l_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_l_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|g_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_g_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|samples(3)|: Each entry $i$ contains the number into which $\bm{b}_i$ has been discretized.
\item \verb|N_int_ind|: Number of integer indices.
\item \verb|int_ind_range(i)|: Number of values the integer index $\alpha_i$ can have.
\item \verb|N_ext_vars|: Number of continuous variables.
\item \verb|ext_vars_start(i)|: Starting point $\lambda_{i1}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_end(i)|: Ending point $\lambda_{i\;\verb|ext_vars_steps(i)|}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_steps(i)|: Number of points into which to descretize the variable $\beta_i$.
\item \verb|part_int_comp(N_int_ind)|: Array corresponding to a selection of a particular integer component in array layout.
\end{itemize}
Sampling, and thus writing the values of $C$ in Eq. \eqref{eq:calculator} given by \verb|l_calculator| or \verb|g_calculator| to the array \verb|BZ_data| can be made with the subroutine \verb|SsTC_sample_sampling_task|.
\begin{lstlisting}[caption={Interface of the ``sampler" sampler.},captionpos=b]
subroutine SsTC_sample_sampling_task(task, system)
  class(SsTC_kslice_task), intent(inout) :: task
  type(SsTC_sys), intent(in)             :: system
end subroutine SsTC_sample_sampling_task
\end{lstlisting}
All the \verb|allocatable| components of both \verb|task| and \verb|system| should be allocated before the subroutine call either by the corresponding constructors or by the user.

Writing to files can be done by means of the subroutine \verb|SsTC_print_sampling|.
\begin{lstlisting}[caption={Interface of the ``sampler" printer.},captionpos=b]
subroutine SsTC_print_sampling(task, system)
  class(SsTC_kpath_task), intent(in) :: task
  type(SsTC_sys), intent(in)         :: system
end subroutine SsTC_print_sampling
\end{lstlisting}
The routine will write a file for each integer index with name \\ \verb|trim(system%name)//'-'//trim(task%name)//'_'trim(num_label)//'.dat'| with num label being an \\ \verb|N_int_ind|-dimensional array with the corresponding integer index in array layout (see Sec. \ref{sec:notation}). Each file will contain, column by column, the following,
\begin{itemize}
\item The components $\verb|ik|i=\{1, 2, 3\}$ of the vector $\bm{k}$ in Eq. \eqref{eq:vec_coords_sampler} corresponding to \verb|id| (3 columns).
\item For each continuous index $i$, the particular values of the data $\lambda_{ij}$ as given by Eq. \eqref{eq:disc_cont} \\ (\verb|size(task%continuous_indices)| columns).
\item The real and imaginary part of the calculator $C^{\alpha}(\bm{k};\beta)$ (2 columns).
\end{itemize}
If further use of the sampled data is intended within the execution of the application, making a copy of \verb|task%BZ_data| is suggested.
\subsection{Integrator module}
This module is centred around creating, sampling, integrating and printing tasks which involve a BZ integral. The ``integrator" task is a derived type
\begin{lstlisting}[caption={Derived type corresponding to a ``integrator" task.},captionpos=b]
type, extends(SsTC_global_k_data) :: SsTC_BZ_integral_task
  !Integration method.
  character(len=120)                             :: method
  !Integration samples.
  integer                                        :: samples(3)
  !Result of the integration, contains the integer
  !index and the continuous index in memory layout, respectively.
  complex(kind=dp), allocatable                  :: result(:, :)
end type SsTC_BZ_integral_task
\end{lstlisting}
For the general calculator Eq. \eqref{eq:calculator}, and the reciprocal space basis vectors $\bm{b}_{\{1, 2, 3\}}$, we identify
\begin{equation}\label{eq:integrator}
\verb|result(alpha, beta)| = \int_{\text{BZ}} \left[d\bm{k}\right]C^{\alpha}(\bm{k},\beta),\quad \left[d\bm{k}\right] = \frac{dk_1 dk_2 dk_3}{(2\pi)^3},
\end{equation}
where $\bm{k}$ is given by
\begin{equation}\label{eq:vec_coords_integrator}
\bm{k} = \sum_{i=1}^3 \bm{b}_i\times (\verb|ik|i-1)/(\verb|samples(i)| - 1).
\end{equation}
An ``integrator" task can be constructed by the function \verb|SsTC_BZ_integral_task_constructor|,
\begin{lstlisting}[caption={Interface of the ``integrator" constructor.},captionpos=b]
subroutine SsTC_BZ_integral_task_constructor(task, name, &
                                             l_calculator, g_calculator, &
                                             method, samples, &
                                             N_int_ind, int_ind_range, &
                                             N_ext_vars, &
                                             ext_vars_start, ext_vars_end, &
                                             ext_vars_steps, &
                                             part_int_comp)

  character(len=*) :: name

  procedure(SsTC_local_calculator), optional  :: l_calculator
  procedure(SsTC_global_calculator), optional :: g_calculator

  character(len=*), optional, intent(in) :: method
  integer, optional, intent(in)          :: samples(3)

  integer, optional, intent(in) :: N_int_ind
  integer, optional, intent(in) :: int_ind_range(N_int_ind)

  integer, optional, intent(in)       :: N_ext_vars
  real(kind=dp), optional, intent(in) :: ext_vars_start(N_ext_vars), &
                                         ext_vars_end(N_ext_vars)
  integer, optional, intent(in)       :: ext_vars_steps(N_ext_vars)

  integer, optional, intent(in) :: part_int_comp(N_int_ind)

  class(SsTC_BZ_integral_task), intent(out) :: task
end subroutine SsTC_BZ_integral_task_constructor
\end{lstlisting}
where
\begin{itemize}
\item \verb|name|: Name given to the task.
\item \verb|l_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_l_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|g_calculator|: Pointer to a function that wants to be sampled, with interface \ref{lst:interface_g_calc}. Only one of \\ \verb|l_calculator| or \verb|g_calculator| can be specified.
\item \verb|method|: is either \verb|"rectangle"| or \verb|"extrapolation"|, default is \verb|rectangle|.
\item \verb|samples(3)|: Each entry $i$ contains the number into which $\bm{b}_i$ has been discretized.
\item \verb|N_int_ind|: Number of integer indices.
\item \verb|int_ind_range(i)|: Number of values the integer index $\alpha_i$ can have.
\item \verb|N_ext_vars|: Number of continuous variables.
\item \verb|ext_vars_start(i)|: Starting point $\lambda_{i1}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_end(i)|: Ending point $\lambda_{i\;\verb|ext_vars_steps(i)|}$ in Eq. \eqref{eq:disc_cont} for the variable $\beta_i$
\item \verb|ext_vars_steps(i)|: Number of points into which to descretize the variable $\beta_i$.
\item \verb|part_int_comp(N_int_ind)|: Array corresponding to a selection of a particular integer component in array layout.
\end{itemize}
Sampling, and thus writing the values of $C$ in Eq. \eqref{eq:calculator} given by \verb|l_calculator| or \verb|g_calculator| to the array \verb|result| can be made with the subroutine \verb|SsTC_sample_and_integrate_BZ_integral_task|.
\begin{lstlisting}[caption={Interface of the ``integrator" sampler.},captionpos=b]
subroutine SsTC_sample_and_integrate_BZ_integral_task(task, system)
  class(SsTC_kslice_task), intent(inout) :: task
  type(SsTC_sys), intent(in)             :: system
end subroutine SsTC_sample_and_integrate_BZ_integral_task
\end{lstlisting}
All the \verb|allocatable| components of both \verb|task| and \verb|system| should be allocated before the subroutine call either by the corresponding constructors or by the user.

If \verb|method = "rectangle"| is selected, the integral in Eq. \eqref{eq:integrator} will be done performed within the rectangle approximation,
\begin{equation}
\int_{\text{BZ}} \left[d\bm{k}\right]C^{\alpha}(\bm{k},\beta) \approx \left(\prod_{i=1}^3 \verb|samples(i)|\right)^{-1}\sum_{\bm{k}\in\text{BZ}} C^{\alpha}(\bm{k},\beta).
\end{equation}
If \verb|method = "extrapolation"| is selected, the integral in Eq. \eqref{eq:integrator} will be done performed by means of extrapolation methods, requiring large memory usage, but capable of greater precision per sampled $\bm{k}$ point. To employ extrapolation, each of the 3 elements of the array \verb|samples(3)| must be either 1, or expressible as $2^n + 1$, $n = 0, 1, \cdots$, or else extrapolation will fail. If this is the case, the rectangle approximation will be employed. The extrapolation method and its implementation are powered by the \verb|F90-Extrapolation-Integration| project, hosted on \href{https://github.com/irukoa/F90-Extrapolation-Integration}{GitHub}.

Writing to files can be done by means of the subroutine \verb|SsTC_print_BZ_integral_task|.
\begin{lstlisting}[caption={Interface of the ``integrator" printer.},captionpos=b]
subroutine SsTC_print_BZ_integral_task(task, system)
  class(SsTC_kpath_task), intent(in) :: task
  type(SsTC_sys), intent(in)         :: system
end subroutine SsTC_print_BZ_integral_task
\end{lstlisting}
The routine will write a file for each integer index with name \\ \verb|trim(system%name)//'-'//trim(task%name)//'_'trim(num_label)//'.dat'| with num label being an \\ \verb|N_int_ind|-dimensional array with the corresponding integer index in array layout (see Sec. \ref{sec:notation}). Each file will contain, column by column, the following,
\begin{itemize}
\item For each continuous index $i$, the particular values of the data $\lambda_{ij}$ as given by Eq. \eqref{eq:disc_cont} \\ (\verb|size(task%continuous_indices)| columns).
\item The real and imaginary part of the calculator $C^{\alpha}(\bm{k};\beta)$ (2 columns).
\end{itemize}
If further use of the sampled data is intended within the execution of the application, making a copy of \verb|task%result| is suggested.
\section{Other routines}
In this section we describe all other ruotines of use to the user.
\subsection{Utility module}
The utility module contains various routines which are of use in the creation of calculators and are widely employed in most of SsTC routines.
\subsubsection{Parameters: Symmetrization and antisymmetrization utilities}
We provide the 4 arrays,
\begin{lstlisting}[caption={Symmetrization and antisymmetrization arrays.},captionpos=b]
!Symmetric.
integer, dimension(6), parameter :: SsTC_alpha_S = (/1, 2, 3, 1, 1, 2/)
integer, dimension(6), parameter :: SsTC_beta_S = (/1, 2, 3, 2, 3, 3/)
!Antisymmetric.
integer, dimension(3), parameter :: SsTC_alpha_A = (/2, 3, 1/)
integer, dimension(3), parameter :: SsTC_beta_A = (/3, 1, 2/)
\end{lstlisting}
which provide linearly independent combinations of (anti)symmetric pairs of 3-dimensional indices. Considering, a symmettic pair of indices $\{i, j\}$, the code
\begin{lstlisting}[caption={Loop over symmetric pair of indices.},captionpos=b]
do ij = 1, 6
  i = SsTC_alpha_S(ij)
  j = SsTC_beta_S(ij)
  .
  .
  .
enddo
\end{lstlisting}
will loop over the 6 linearly independent combination of indices. In the same way and now considering a pair of antisymmetric indices $\{i, j\}$,
\begin{lstlisting}[caption={Loop over antisymmetric pair of indices.},captionpos=b]
do ij = 1, 3
  i = SsTC_alpha_A(ij)
  j = SsTC_beta_A(ij)
  .
  .
  .
enddo
\end{lstlisting}
will loop over the 3 linearly independent combination of indices.
\subsubsection{Utilities}
The function \verb|SsTC_utility_delta|,
\begin{lstlisting}[caption={Interface of ``utility delta".},captionpos=b]
function SsTC_utility_delta(x) result(res)

  real(kind=dp), intent(in) :: x
  real(kind=dp) :: res

end function SsTC_utility_delta
\end{lstlisting}
and the function \verb|SsTC_utility_delta_vec|,
\begin{lstlisting}[caption={Interface of ``utility delta vector".},captionpos=b]
function SsTC_utility_delta_vec(x) result(res)

  real(kind=dp), intent(in) :: x(:)
  real(kind=dp) :: res(size(x))

end function SsTC_utility_delta_vec
\end{lstlisting}
will approcimate the Dirac delta distribution $\delta(x)$ and $\delta(\bm{x})$ respectively.

The function \verb|SsTC_utility_get_degen|,
\begin{lstlisting}[caption={Interface of ``utility get degeneracy of lists".},captionpos=b]
function SsTC_utility_get_degen(eig, degen_thr) result(deg)

  real(kind=dp), intent(in)  :: degen_thr
  real(kind=dp), intent(in)  :: eig(:)

  integer :: deg(size(eig))

end function SsTC_utility_get_degen
\end{lstlisting}
will take as an input an ascending ordered list \verb|eig| of real elements and return an integer valued list \verb|deg| of the same size of \verb|eig|, with the degree of degeneracy of each element in \verb|eig| stored in the respective element of \verb|deg| as determined by the threshold \verb|degen_thr|. The values each element of \verb|deg| can have are the following,
\begin{itemize}
\item $\verb|deg(i)| = 1$: Nondegenerate subspace.
\item $\verb|deg(i)| = N>1$: Degenerate subspace with degree of degeneracy $N$, the next $N-1$ elements of the list have the value $0$.
\item $\verb|deg(i)| = 0$: Level belongs to a degenerate subspace.
\end{itemize}

The routine \verb|SsTC_utility_diagonalize|,
\begin{lstlisting}[caption={Interface of ``utility diagonalize".},captionpos=b]
subroutine SsTC_utility_diagonalize(mat, dim, eig, rot, error)

  integer, intent(in)           :: dim
  complex(kind=dp), intent(in)  :: mat(dim, dim)
  real(kind=dp), intent(out)    :: eig(dim)      !Eigenvalues.
  complex(kind=dp), intent(out) :: rot(dim, dim) !Eigenvectors.
  logical, intent(inout)        :: error

end subroutine SsTC_utility_diagonalize
\end{lstlisting}
computes the diagonalization of the hermitian $\verb|dim|\times\verb|dim|$ matrix \verb|mat|. It returns the eigenvalues \verb|eig| sorted in ascending order and the unitary rotation \verb|rot|. If an error occurs in the calculation, \verb|error=.true.| is set.

The routine \verb|SsTC_utility_schur|,
\begin{lstlisting}[caption={Interface of ``utility Schur".},captionpos=b]
subroutine SsTC_utility_schur(mat, dim, T, Z, error, S)

  integer, intent(in)                     :: dim
  complex(kind=dp), intent(in)            :: mat(dim, dim)
  complex(kind=dp), intent(out)           :: T(dim)      !Eigenvalues.
  complex(kind=dp), intent(out)           :: Z(dim, dim) !Eigenvectors.
  logical, intent(inout)                  :: error
  complex(kind=dp), intent(out), optional :: S(dim, dim) !Schur Form.
  
end subroutine SsTC_utility_schur
\end{lstlisting}
computes the Schur form of the complex $\verb|dim|\times\verb|dim|$ matrix \verb|mat|. It returns the eigenvalues \verb|T| and the unitary rotation \verb|Z|. If an error occurs in the calculation, \verb|error=.true.| is set. Optionally, it returns the Schur form \verb|S|, obeying $\verb|mat|= \verb|Z|*\verb|S|*\verb|Z|^{\dagger}$.

The routine \verb|SsTC_utility_SVD|,
\begin{lstlisting}[caption={Interface of ``utility SVD".},captionpos=b]
subroutine SsTC_utility_SVD(mat, sigma, error, U, V)

  complex(kind=dp), intent(in)            :: mat(:, :)
  real(kind=dp), intent(out)              :: sigma(size(mat(:, 1)), &
                                             size(mat(1, :)))
  logical, intent(inout)                  :: error
  complex(kind=dp), intent(out), optional :: U(size(mat(:, 1)), &
                                             size(mat(:, 1))), &
                                             V(size(mat(1, :)), &              
                                             size(mat(1, :)))
                                             
end subroutine SsTC_utility_SVD
\end{lstlisting}
computes the singular value decomposition of the complex rectangular matrix \verb|mat|. It returns the eigenvalues \verb|sigma|. If an error occurs in the calculation, \verb|error=.true.| is set. Optionally, it returns and the unitary rotations \verb|U|, \verb|V| obeting $\verb|mat|= \verb|U|*\verb|sigma|*\verb|V|^{\dagger}$.

The function \verb|SsTC_utility_exphs|,
\begin{lstlisting}[caption={Interface of ``utility exponential of matrix".},captionpos=b]
function SsTC_utility_exphs(mat, dim, skew, error) result(exphs)

  integer, intent(in)          :: dim
  complex(kind=dp), intent(in) :: mat(dim, dim)
  logical, intent(in)          :: skew
  logical, intent(inout)       :: error
  
  complex(kind=dp) :: exphs(dim, dim)
  
end function SsTC_utility_exphs
\end{lstlisting}
computes the matrix exponential of the (skew)hermitian $\verb|dim|\times\verb|dim|$ matrix \verb|mat|. The (skew)hermiticuty of \verb|mat| is specified by \verb|skew|, which is \verb|.false.| for a hermitian \verb|mat| and \verb|.true.| for a skewhermitian \verb|mat|. It returns $\verb|exphs| = e^{\verb|mat|}$. If an error occurs in the calculation, \verb|error=.true.| is set.

The function \verb|SsTC_utility_logu|,
\begin{lstlisting}[caption={Interface of ``utility logarithm of matrix".},captionpos=b]
function SsTC_utility_logu(mat, dim, error) result(logu)

  integer, intent(in)          :: dim
  complex(kind=dp), intent(in) :: mat(dim, dim)
  logical, intent(inout)       :: error

  complex(kind=dp) :: logu(dim, dim)
  
end function SsTC_utility_logu
\end{lstlisting}
computes the matrix logarithm of the unitary $\verb|dim|\times\verb|dim|$ matrix \verb|mat|. It returns $\verb|logu| = \text{log}\left(\verb|mat|\right)$. If an error occurs in the calculation, \verb|error=.true.| is set.
\subsection{Extrapolation integration module}
Extrapolation integration is a submodule of the SsTC project, powered by the \\ \verb|F90-Extrapolation-Integration| project, hosted on \href{https://github.com/irukoa/F90-Extrapolation-Integration}{GitHub}. We refer the reader to the user's guide provided by the repository for a full review of the routines provided by the module.

In SsTC, the routines are made public to the user with the following renaming.
\begin{lstlisting}[caption={Renaming of extrapolation routines.},captionpos=b]
SsTC_integral_extrapolation => integral_extrapolation, &
SsTC_shrink_array => shrink_array, &
SsTC_expand_array => expand_array
\end{lstlisting}
\subsection{Data structures module}\label{sec:data_structures}
\subsection{Local k-quantities module}\label{sec:local_k_quantities}
\subsection{Comms module}
\section{Modularity}\label{sec:modularity}
\section{Usage in high performance computing}
SsTC uses a hybrid parallelization model, using the MPI \cite{messagepassinginterfaceforumMPIMessagePassingInterface2021} and the OpenMP \cite{openmparchitecturereviewboardOpenMPApplicationProgramming2021} libraries.
\section{Examples}
\section{Suggested practices}
\bibliographystyle{unsrt}
\bibliography{bibdata}
\end{document}
